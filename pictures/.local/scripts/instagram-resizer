#!/usr/bin/env bash

# Produces correctly cropped Instagram photos in the current working directory

set -euo pipefail

if ! command -v magick &>/dev/null; then
    echo 'Error: ImageMagick is not installed.'
    exit 1
fi

if ! command -v exiv2 &>/dev/null; then
    echo 'Error: Exiv2 is not installed.'
    exit 1
fi

if ! command -v shasum &>/dev/null; then
    echo 'Error: shasum is not installed.'
    exit 1
fi

crop='square'
border_color='#ffffff'
replace_files_option=false
smart_replace_files_option=true
signature=''
date_option=false
hash_option=false

print_usage() {
    echo 'Usage: instagram-resizer --crop <crop> --border <border-color> [--replace] [--no-smart-replace]'
}

while [[ $# -gt 0 ]]; do
    case "$1" in
    '--crop')
        crop="$2"
        shift 2
        ;;
    '--border')
        border_color="$2"
        shift 2
        ;;
    '--replace')
        replace_files_option=true
        shift
        ;;
    '--no-smart-replace')
        smart_replace_files_option=false
        shift
        ;;
    '--sign')
        signature="$2"
        shift 2
        ;;
    '--date')
        date_option=true
        shift
        ;;
    '--hash')
        hash_option=true
        shift
        ;;
    '-h' | '--help')
        print_usage
        exit 0
        ;;
    *)
        printf 'Unknown option: %q\n' "$1"
        print_usage
        exit 1
        ;;
    esac
done

case "$crop" in
'square')
    width=1080
    height=$width
    ;;
'landscape')
    width=1080
    height=566
    ;;
'portrait')
    width=1080
    height=1350
    ;;
*)
    echo 'Error: Instagram post crop can be square, landscape, or portrait:'
    echo
    echo 'square      1:1      1080x1080'
    echo 'landscape   1.91:1   1080x566'
    echo 'portrait    4:5      1080x1350'
    echo
    echo 'Width of 1080 pixels and aspect ratio between 1.91:1 and 4:5.'
    echo
    echo 'https://help.instagram.com/1631821640426723'
    echo
    echo 'https://www.adobe.com/express/discover/sizes/instagram'
    print_usage
    exit 1
    ;;
esac

min_border=$((7 * (width / 100)))

hex=${border_color#\#}
if [[ ! "$hex" =~ ^[0-9a-fA-F]{6}$ ]]; then
    printf 'Error: Invalid border color format. Use a 6-digit hex value like %q' '#000000'
    exit 1
fi
r=$((16#${hex:0:2}))
g=$((16#${hex:2:2}))
b=$((16#${hex:4:2}))
luminance=$(((r * 2126 + g * 7152 + b * 722) / 10000))
if [ "$luminance" -gt 128 ]; then
    watermark_color='#000000'
else
    watermark_color='#ffffff'
fi

case "$(uname -s)" in
Linux)
    watermark_font="$HOME/.local/share/fonts/UbuntuMonoNerdFontMono-Regular.ttf"
    ;;
Darwin)
    watermark_font="$HOME/Library/Fonts/UbuntuMonoNerdFontMono-Regular.ttf"
    ;;
*)
    echo 'Error: Operating system not supported (no font).'
    exit 1
    ;;
esac

while IFS= read -r source_file; do
    anonymous_file_name=$({
        file_basename=$(basename "$source_file")
        file_name_sha1sum=("$(echo -n "${file_basename%.*}" | shasum)")
        echo "${file_name_sha1sum[0]:0:6}"
    })
    dest_file="./$(echo "${anonymous_file_name}_${crop}" | tr '[a-z]' '[A-Z]').jpg"

    if [ -e "$dest_file" ]; then
        case "$replace_files_option" in
        true)
            source_mod_time=$(date -r "$source_file" +%Y%m%d%H%M%S)
            dest_mod_time=$(date -r "$dest_file" +%Y%m%d%H%M%S)

            if [ "$smart_replace_files_option" == true ] && [ "$source_mod_time" -le "$dest_mod_time" ]; then
                printf "Info(%q): Destination newer than source. Skipping with 'smart-replace'. Use '--no-smart-replace' option here.\n" "$source_file"
                continue
            fi
            ;;
        false)
            printf 'Error(%q): File or directory already exists %q.\n' "$source_file" "$dest_file"
            exit 1
            ;;
        esac
    fi

    magick "$source_file" \
        -resize "$((width - min_border * 2))x$((height - min_border * 2))>" -background "$border_color" -gravity center -extent "${width}x${height}" -colorspace sRGB \
        -rotate 90 -gravity southwest -font "$watermark_font" -pointsize "$((width / 36))" -stroke "$watermark_color" -fill "$watermark_color" -strokewidth "$((width / 1080))" -annotate "+$((width / 108))+$((width / 108))" "$({
            annotation="${signature}"

            if [ "$date_option" == true ]; then
                # Extract capture time from EXIF metadata (format: YYYYMM)
                annotation+="  $({
                    capture_time_array=($(exiv2 -q -Qm -Pkt "$source_file" | grep "Exif.\(Photo\|Image\).DateTimeOriginal[[:space:]]\+"))
                    capture_time="${capture_time_array[1]//:/}"
                    if [[ -n "$capture_time" ]]; then
                        echo "${capture_time%??}"
                    else
                        echo 'unknown'
                    fi
                })"
            fi

            if [ "$hash_option" == true ]; then
                annotation+="  ${anonymous_file_name}"
            fi

            echo "$annotation"
        })" -rotate 270 \
        "$dest_file" && exiv2 rm "$dest_file"
done
